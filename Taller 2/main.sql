-- JUAN DAVID LOPEZ BECERRA

-- Punto 1 Cruzar estas tablas para encontrar las habilidades (en inglés) de cada Pokémon, y mostrar
-- el ID de la pokedex, el nombre del Pokémon y el nombre de la habilidad.
SELECT JLEON.POKEDEX.ID_P, JLEON.POKEDEX.IDENTIFIER_P, JLEON.ABILITY_NAMES.NAME_A AS HABILIDAD
FROM JLEON.POKEDEX 
JOIN JLEON.POKEDEX_2
ON UPPER(JLEON.POKEDEX.IDENTIFIER_P) = UPPER(JLEON.POKEDEX_2.NAME) AND JLEON.POKEDEX.ID_P = JLEON.POKEDEX_2.POKEDEX_NUMBER
JOIN JLEON.POKEMON_ABILITIES ON JLEON.POKEDEX.ID_P = JLEON.POKEMON_ABILITIES.POKEMON_ID
JOIN JLEON.ABILITY_NAMES ON JLEON.POKEMON_ABILITIES.ABILITY_ID = JLEON.ABILITY_NAMES.ABILITY_ID
JOIN JLEON.LANGUAJE ON JLEON.ABILITY_NAMES.LOCAL_LANGUAGE_ID = JLEON.LANGUAJE.ID WHERE JLEON.LANGUAJE.ISO639 = 'en'; 

-- Create View
CREATE VIEW T2_LOPEZ_JUAN_1 AS SELECT JLEON.POKEDEX.ID_P, JLEON.POKEDEX.IDENTIFIER_P, JLEON.ABILITY_NAMES.NAME_A AS HABILIDAD
FROM JLEON.POKEDEX 
JOIN JLEON.POKEDEX_2
ON UPPER(JLEON.POKEDEX.IDENTIFIER_P) = UPPER(JLEON.POKEDEX_2.NAME) AND JLEON.POKEDEX.ID_P = JLEON.POKEDEX_2.POKEDEX_NUMBER
JOIN JLEON.POKEMON_ABILITIES ON JLEON.POKEDEX.ID_P = JLEON.POKEMON_ABILITIES.POKEMON_ID
JOIN JLEON.ABILITY_NAMES ON JLEON.POKEMON_ABILITIES.ABILITY_ID = JLEON.ABILITY_NAMES.ABILITY_ID
JOIN JLEON.LANGUAJE ON JLEON.ABILITY_NAMES.LOCAL_LANGUAGE_ID = JLEON.LANGUAJE.ID WHERE JLEON.LANGUAJE.ISO639 = 'en'; 

-- Grant Permisson to JLEON
GRANT SELECT ON IS324304.T2_LOPEZ_JUAN_1 TO JLEON;

-- Punto 2 Seleccione a todos los pokemon que estén en la pokedex1 y que NO estén en la pokedex2.
SELECT IDENTIFIER_P
FROM JLEON.POKEDEX 
LEFT JOIN JLEON.POKEDEX_2 
ON JLEON.POKEDEX.ID_P = JLEON.POKEDEX_2.POKEDEX_NUMBER 
WHERE JLEON.POKEDEX_2.POKEDEX_NUMBER IS NULL;

CREATE VIEW T2_LOPEZ_JUAN_2 AS SELECT IDENTIFIER_P
FROM JLEON.POKEDEX 
LEFT JOIN JLEON.POKEDEX_2 
ON JLEON.POKEDEX.ID_P = JLEON.POKEDEX_2.POKEDEX_NUMBER 
WHERE JLEON.POKEDEX_2.POKEDEX_NUMBER IS NULL;

-- Grant Access to JLEON
GRANT SELECT ON IS324304.T2_LOPEZ_JUAN_2 TO JLEON;

-- OTHER WAY TO IMPLEMENT:

SELECT IDENTIFIER_P
FROM Jleon.pokedex
WHERE JLEON.POKEDEX.ID_P NOT IN (SELECT POKEDEX_NUMBER FROM Jleon.pokedex_2)

-- Punto 3 Seleccione las habilidades en japones de todos los pokemon que sean de la temporada 1 únicamente
SELECT JLEON.ABILITY_NAMES.NAME_A 
FROM JLEON.POKEDEX 
JOIN JLEON.POKEDEX_2
ON UPPER(JLEON.POKEDEX.IDENTIFIER_P) = UPPER(JLEON.POKEDEX_2.NAME) AND JLEON.POKEDEX.ID_P = JLEON.POKEDEX_2.POKEDEX_NUMBER
JOIN JLEON.POKEMON_ABILITIES ON JLEON.POKEDEX.ID_P = JLEON.POKEMON_ABILITIES.POKEMON_ID
JOIN JLEON.ABILITY_NAMES ON JLEON.POKEMON_ABILITIES.ABILITY_ID = JLEON.ABILITY_NAMES.ABILITY_ID
JOIN JLEON.LANGUAJE ON JLEON.ABILITY_NAMES.LOCAL_LANGUAGE_ID = JLEON.LANGUAJE.ID 
WHERE JLEON.LANGUAJE.ISO639 = 'ja' and JLEON.POKEDEX_2.GENERATION = 1; 

CREATE VIEW T2_LOPEZ_JUAN_3 AS SELECT JLEON.ABILITY_NAMES.NAME_A 
FROM JLEON.POKEDEX 
JOIN JLEON.POKEDEX_2
ON UPPER(JLEON.POKEDEX.IDENTIFIER_P) = UPPER(JLEON.POKEDEX_2.NAME) AND JLEON.POKEDEX.ID_P = JLEON.POKEDEX_2.POKEDEX_NUMBER
JOIN JLEON.POKEMON_ABILITIES ON JLEON.POKEDEX.ID_P = JLEON.POKEMON_ABILITIES.POKEMON_ID
JOIN JLEON.ABILITY_NAMES ON JLEON.POKEMON_ABILITIES.ABILITY_ID = JLEON.ABILITY_NAMES.ABILITY_ID
JOIN JLEON.LANGUAJE ON JLEON.ABILITY_NAMES.LOCAL_LANGUAGE_ID = JLEON.LANGUAJE.ID 
WHERE JLEON.LANGUAJE.ISO639 = 'ja' and JLEON.POKEDEX_2.GENERATION = 1; 

-- Grant Access to JLEON
GRANT SELECT ON IS324304.T2_LOPEZ_JUAN_3 TO JLEON;

-- Punto 4 Encuentre el total de pokemon por cada temporada. (cambie el nombre de la columna de la agrupación a “TOTAL_TEMPORADA”) 
SELECT JLEON.POKEDEX_2.GENERATION, COUNT(JLEON.POKEDEX_2.GENERATION) AS TOTAL_TEMPORADA
FROM JLEON.POKEDEX_2 
GROUP BY JLEON.POKEDEX_2.GENERATION;

-- Create View and Give Access to JLEON
CREATE VIEW T2_LOPEZ_JUAN_4 AS SELECT JLEON.POKEDEX_2.GENERATION, COUNT(JLEON.POKEDEX_2.GENERATION) AS TOTAL_TEMPORADA
FROM JLEON.POKEDEX_2 
GROUP BY JLEON.POKEDEX_2.GENERATION;

-- Grant Access to JLEON
GRANT SELECT ON IS324304.T2_LOPEZ_JUAN_4 TO JLEON;


-- Punto 5 Encuentre el total de cada tipo de Pokémon (JLEON.POKEDEX_2.TYPE_1) por cada temporada, y seleccione únicamente aquellos tipos que tengan más de 10 pokemon. El resultado debe tener 3 columnas (tipo, temporada y total).
SELECT JLEON.POKEDEX_2.TYPE_1, JLEON.POKEDEX_2.GENERATION, COUNT(JLEON.POKEDEX_2.TYPE_1) AS TOTAL
FROM JLEON.POKEDEX_2 
GROUP BY JLEON.POKEDEX_2.TYPE_1, JLEON.POKEDEX_2.GENERATION
HAVING COUNT(JLEON.POKEDEX_2.TYPE_1) > 10;
-- nota: HAVING es usado en cambio de WHERE cuando se usa GROUP BY

-- Create View and Give Access to JLEON
CREATE VIEW T2_LOPEZ_JUAN_5 AS SELECT JLEON.POKEDEX_2.TYPE_1, JLEON.POKEDEX_2.GENERATION, COUNT(JLEON.POKEDEX_2.TYPE_1) AS TOTAL
FROM JLEON.POKEDEX_2 
GROUP BY JLEON.POKEDEX_2.TYPE_1, JLEON.POKEDEX_2.GENERATION
HAVING COUNT(JLEON.POKEDEX_2.TYPE_1) > 10;

-- Grant Access to JLEON
GRANT SELECT ON IS324304.T2_LOPEZ_JUAN_5 TO JLEON;

-- SECTION 2

-- Describe Tables from JLEON
-- MOV_ROLES
-- MOV_MOVIES
-- MOV_ACTORS
-- MOV_MOVIES_GENRERS
-- MOV_MOVIES_DIRECTORS
-- MOV_DIRECTORS
-- MOV_DIRECTORS_GENRERS

DESCRIBE JLEON.MOV_MOVIES;
DESCRIBE JLEON.MOV_MOVIES_DIRECTORS;
DESCRIBE JLEON.MOV_MOVIES_GENRERS;
DESCRIBE JLEON.MOV_ROLES;
DESCRIBE JLEON.MOV_ACTORS;
DESCRIBE JLEON.MOV_DIRECTORS;
DESCRIBE JLEON.MOV_DIRECTORS_GENRERS;

-- The Schemas are:
-- SQL> DESCRIBE JLEON.MOV_MOVIES;
-- Name	Null?	Type
-- ID	NOT NULL	NUMBER(11)
-- NAME		VARCHAR2(100)
-- YEAR		NUMBER(11)
-- RANK		FLOAT(126)

-- SQL> DESCRIBE JLEON.MOV_MOVIES_DIRECTORS;
-- Name	Null?	Type
-- DIRECTOR_ID	NOT NULL	NUMBER(11)
-- MOVIE_ID	NOT NULL	NUMBER(11)

-- SQL> DESCRIBE JLEON.MOV_MOVIES_GENRERS;
-- Name	Null?	Type
-- MOVIE_ID	NOT NULL	NUMBER(11)
-- GENRE	NOT NULL	VARCHAR2(100)

-- SQL> DESCRIBE JLEON.MOV_ROLES;
-- Name	Null?	Type
-- ACTOR_ID	NOT NULL	NUMBER(11)
-- MOVIE_ID	NOT NULL	NUMBER(11)
-- ROLE	NOT NULL	VARCHAR2(100)

-- SQL> DESCRIBE JLEON.MOV_ACTORS;
-- Name	Null?	Type
-- ID	NOT NULL	NUMBER(11)
-- FIRST_NAME		VARCHAR2(100)
-- LAST_NAME		VARCHAR2(100)
-- GENDER		CHAR(1)

-- SQL> DESCRIBE JLEON.MOV_DIRECTORS;
-- Name	Null?	Type
-- ID	NOT NULL	NUMBER(11)
-- FIRST_NAME		VARCHAR2(100)
-- LAST_NAME		VARCHAR2(100)

-- SQL> DESCRIBE JLEON.MOV_DIRECTORS_GENRERS;
-- Name	Null?	Type
-- DIRECTOR_ID		NUMBER(11)
-- GENRE		VARCHAR2(100)
-- PROB		FLOAT(126)

-- Punto 7 Seleccione la cantidad de películas que hay por cada año, y el ranking promedio para ese año. El ranking debe tener como mucho 2 decimales, y no debe ser nulo, en caso de serlo se debe guardar un “0”.

SELECT JLEON.MOV_MOVIES.YEAR, COUNT(JLEON.MOV_MOVIES.YEAR) AS TOTAL, NVL(ROUND(AVG(JLEON.MOV_MOVIES.RANK), 2),0) AS RANKING
FROM JLEON.MOV_MOVIES
GROUP BY JLEON.MOV_MOVIES.YEAR;

-- Create View and Give Access to JLEON
CREATE VIEW T2_LOPEZ_JUAN_7 AS SELECT JLEON.MOV_MOVIES.YEAR, COUNT(JLEON.MOV_MOVIES.YEAR) AS TOTAL, NVL(ROUND(AVG(JLEON.MOV_MOVIES.RANK), 2),0) 
AS RANKING FROM JLEON.MOV_MOVIES GROUP BY JLEON.MOV_MOVIES.YEAR; 

-- Grant Access to JLEON
GRANT SELECT ON IS324304.T2_LOPEZ_JUAN_7 TO JLEON;

-- Punto 8 Seleccione el id, nombre y apellido de cada director, junto con la cantidad de actores DIFERENTES que ha trabajado.
SELECT JLEON.MOV_DIRECTORS.ID, JLEON.MOV_DIRECTORS.FIRST_NAME, JLEON.MOV_DIRECTORS.LAST_NAME, COUNT(DISTINCT JLEON.MOV_ROLES.ACTOR_ID) AS TOTAL_ACTORES
FROM JLEON.MOV_DIRECTORS
INNER JOIN JLEON.MOV_MOVIES_DIRECTORS ON JLEON.MOV_DIRECTORS.ID = JLEON.MOV_MOVIES_DIRECTORS.DIRECTOR_ID
INNER JOIN JLEON.MOV_ROLES ON JLEON.MOV_MOVIES_DIRECTORS.MOVIE_ID = JLEON.MOV_ROLES.MOVIE_ID
GROUP BY JLEON.MOV_DIRECTORS.ID, JLEON.MOV_DIRECTORS.FIRST_NAME, JLEON.MOV_DIRECTORS.LAST_NAME;

CREATE VIEW T2_LOPEZ_JUAN_8 AS SELECT JLEON.MOV_DIRECTORS.ID, JLEON.MOV_DIRECTORS.FIRST_NAME, JLEON.MOV_DIRECTORS.LAST_NAME, 
COUNT(DISTINCT JLEON.MOV_ROLES.ACTOR_ID) AS TOTAL_ACTORES FROM JLEON.MOV_DIRECTORS INNER JOIN JLEON.MOV_MOVIES_DIRECTORS ON 
JLEON.MOV_DIRECTORS.ID = JLEON.MOV_MOVIES_DIRECTORS.DIRECTOR_ID INNER JOIN JLEON.MOV_ROLES ON 
JLEON.MOV_MOVIES_DIRECTORS.MOVIE_ID = JLEON.MOV_ROLES.MOVIE_ID GROUP BY JLEON.MOV_DIRECTORS.ID, JLEON.MOV_DIRECTORS.FIRST_NAME, 
JLEON.MOV_DIRECTORS.LAST_NAME;

-- Grant Access to JLEON
GRANT SELECT ON IS324304.T2_LOPEZ_JUAN_8 TO JLEON;

-- Punto 9 Por cada genero diferente de películas, encuentre el total de películas dentro de cada género y el promedio de calificación de cada uno.

SELECT JLEON.MOV_MOVIES_GENRERS.GENRE, COUNT(JLEON.MOV_MOVIES_GENRERS.GENRE) AS TOTAL, ROUND(AVG(JLEON.MOV_MOVIES.RANK), 2) AS AVERAGE_RANKING
FROM JLEON.MOV_MOVIES_GENRERS
INNER JOIN JLEON.MOV_MOVIES ON JLEON.MOV_MOVIES_GENRERS.MOVIE_ID = JLEON.MOV_MOVIES.ID
GROUP BY JLEON.MOV_MOVIES_GENRERS.GENRE;


-- Create View and Give Access to JLEON
CREATE VIEW T2_LOPEZ_JUAN_9 AS SELECT JLEON.MOV_MOVIES_GENRERS.GENRE, COUNT(JLEON.MOV_MOVIES_GENRERS.GENRE) AS TOTAL, 
ROUND(AVG(JLEON.MOV_MOVIES.RANK), 2) AS AVERAGE_RANKING FROM JLEON.MOV_MOVIES_GENRERS INNER JOIN JLEON.MOV_MOVIES ON 
JLEON.MOV_MOVIES_GENRERS.MOVIE_ID = JLEON.MOV_MOVIES.ID GROUP BY JLEON.MOV_MOVIES_GENRERS.GENRE;

-- Grant Access to JLEON
GRANT SELECT ON IS324304.T2_LOPEZ_JUAN_9 TO JLEON;

-- 10) Seleccione los géneros diferentes de películas que no aparecen en la tabla correspondiente, pero que si aparecen registrados dentro de los géneros que hacen los directores.

SELECT DISTINCT JLEON.MOV_DIRECTORS_GENRERS.GENRE
FROM JLEON.MOV_DIRECTORS_GENRERS
WHERE JLEON.MOV_DIRECTORS_GENRERS.GENRE NOT IN (SELECT JLEON.MOV_MOVIES_GENRERS.GENRE FROM JLEON.MOV_MOVIES_GENRERS);

-- Create View and Give Access to JLEON
CREATE VIEW T2_LOPEZ_JUAN_10 AS SELECT DISTINCT JLEON.MOV_DIRECTORS_GENRERS.GENRE FROM JLEON.MOV_DIRECTORS_GENRERS WHERE 
JLEON.MOV_DIRECTORS_GENRERS.GENRE NOT IN (SELECT JLEON.MOV_MOVIES_GENRERS.GENRE FROM JLEON.MOV_MOVIES_GENRERS);

-- Grant Access to JLEON
GRANT SELECT ON IS324304.T2_LOPEZ_JUAN_10 TO JLEON;

-- Punto 11: No tiene sentido ya que no se puede hacer un join entre las tablas MOV_DIRECTORS_GENRERS y MOV_MOVIES_GENRERS, ya que no tienen una columna en común.

-- SECTION 3

-- Tabla Usando la tabla:
-- CUSTOMERS_VEHICLES_RELATION
-- CUSTOMERS
-- VEHICLES

DESCRIBE JLEON.CUSTOMERS;
DESCRIBE JLEON.CUSTOMERS_VEHICLES_RELATION;
DESCRIBE JLEON.VEHICLES;

-- Name	Null?	Type
-- ID_CUSTOMER	NOT NULL	NUMBER(38)
-- NAME		VARCHAR2(20)
-- LAST_NAME		VARCHAR2(20)
-- AGE		NUMBER(38)
-- LOCATION		VARCHAR2(200)
-- COMPANY		VARCHAR2(200)

-- SQL> DESCRIBE JLEON.CUSTOMERS_VEHICLES_RELATION;
-- Name	Null?	Type
-- ID_CUSTOMER		NUMBER(38)
-- ID_VEHICLE		NUMBER(38)
-- MILEAGE_KM		NUMBER(38)
-- VIN		VARCHAR2(20)
-- USE_TIME_DAYS		NUMBER(38)

-- SQL> DESCRIBE JLEON.VEHICLES;
-- Name	Null?	Type
-- ID_VEHICLE	NOT NULL	NUMBER(38)
-- BRAND		VARCHAR2(20)
-- MODEL		VARCHAR2(20)
-- YEAR		NUMBER(38)
-- COLOR		VARCHAR2(20)

-- 13) Seleccione el nombre, apellido, edad, marca del vehículo, modelo, año y color de las personas que posean un vehículo.

SELECT JLEON.CUSTOMERS.NAME, JLEON.CUSTOMERS.LAST_NAME, JLEON.CUSTOMERS.AGE, JLEON.VEHICLES.BRAND, JLEON.VEHICLES.MODEL, JLEON.VEHICLES.YEAR, JLEON.VEHICLES.COLOR
FROM JLEON.CUSTOMERS
INNER JOIN JLEON.CUSTOMERS_VEHICLES_RELATION ON JLEON.CUSTOMERS.ID_CUSTOMER = JLEON.CUSTOMERS_VEHICLES_RELATION.ID_CUSTOMER
INNER JOIN JLEON.VEHICLES ON JLEON.CUSTOMERS_VEHICLES_RELATION.ID_VEHICLE = JLEON.VEHICLES.ID_VEHICLE;

-- Create View and Give Access to JLEON
CREATE VIEW T2_LOPEZ_JUAN_13 AS SELECT JLEON.CUSTOMERS.NAME, JLEON.CUSTOMERS.LAST_NAME, JLEON.CUSTOMERS.AGE, JLEON.VEHICLES.BRAND, 
JLEON.VEHICLES.MODEL, JLEON.VEHICLES.YEAR, JLEON.VEHICLES.COLOR FROM JLEON.CUSTOMERS INNER JOIN JLEON.CUSTOMERS_VEHICLES_RELATION ON 
JLEON.CUSTOMERS.ID_CUSTOMER = JLEON.CUSTOMERS_VEHICLES_RELATION.ID_CUSTOMER INNER JOIN JLEON.VEHICLES ON 
JLEON.CUSTOMERS_VEHICLES_RELATION.ID_VEHICLE = JLEON.VEHICLES.ID_VEHICLE;

-- Grant Access to JLEON
GRANT SELECT ON IS324304.T2_LOPEZ_JUAN_13 TO JLEON;

-- 14) Encuentre el promedio de edad de las personas que NO poseen vehículos.

SELECT AVG(JLEON.CUSTOMERS.AGE)
FROM JLEON.CUSTOMERS
LEFT JOIN JLEON.CUSTOMERS_VEHICLES_RELATION ON JLEON.CUSTOMERS.ID_CUSTOMER = JLEON.CUSTOMERS_VEHICLES_RELATION.ID_CUSTOMER
WHERE JLEON.CUSTOMERS_VEHICLES_RELATION.ID_CUSTOMER IS NULL;

-- Create View and Give Access to JLEON
CREATE VIEW T2_LOPEZ_JUAN_14 AS SELECT AVG(JLEON.CUSTOMERS.AGE) as AVERAGE_NO_VEHICLE_AGE
FROM JLEON.CUSTOMERS
LEFT JOIN JLEON.CUSTOMERS_VEHICLES_RELATION ON JLEON.CUSTOMERS.ID_CUSTOMER = JLEON.CUSTOMERS_VEHICLES_RELATION.ID_CUSTOMER
WHERE JLEON.CUSTOMERS_VEHICLES_RELATION.ID_CUSTOMER IS NULL;

-- Grant Access to JLEON
GRANT SELECT ON IS324304.T2_LOPEZ_JUAN_14 TO JLEON;

-- 15) Seleccione la marca, el total de vehículos de esa marca y el año del modelo más reciente de
-- esa marca, de los vehículos que no han sido adquiridos por ningún cliente.
SELECT JLEON.VEHICLES.BRAND, COUNT(JLEON.VEHICLES.ID_VEHICLE) AS TOTAL_VEHICLES, MAX(JLEON.VEHICLES.YEAR) AS MAX_YEAR
FROM JLEON.VEHICLES
LEFT JOIN JLEON.CUSTOMERS_VEHICLES_RELATION ON JLEON.VEHICLES.ID_VEHICLE = JLEON.CUSTOMERS_VEHICLES_RELATION.ID_VEHICLE
WHERE JLEON.CUSTOMERS_VEHICLES_RELATION.ID_CUSTOMER IS NULL
GROUP BY JLEON.VEHICLES.BRAND;

-- Create View and Give Access to JLEON
CREATE VIEW T2_LOPEZ_JUAN_15 AS SELECT JLEON.VEHICLES.BRAND, COUNT(JLEON.VEHICLES.ID_VEHICLE) AS TOTAL_VEHICLES, MAX(JLEON.VEHICLES.YEAR) AS MAX_YEAR
FROM JLEON.VEHICLES
LEFT JOIN JLEON.CUSTOMERS_VEHICLES_RELATION ON JLEON.VEHICLES.ID_VEHICLE = JLEON.CUSTOMERS_VEHICLES_RELATION.ID_VEHICLE
WHERE JLEON.CUSTOMERS_VEHICLES_RELATION.ID_CUSTOMER IS NULL
GROUP BY JLEON.VEHICLES.BRAND;

-- Grant Access to JLEON
GRANT SELECT ON IS324304.T2_LOPEZ_JUAN_15 TO JLEON;

-- 16) Para generar un informe detallado de la tienda, se le solicita una tabla donde muestre toda
-- la información importante de clientes (incluidos los que aún no poseen vehículos) y de
-- vehículos (incluyendo aquellos que no han sido comprados), donde aparezca el nombre,
-- apellido y edad del cliente, kilómetros recorridos, marca, modelo, año y color del vehículo.
-- Este resultado debe estar ordenado por Apellido y nombre. Además, debe agregar una
-- columna “VERIFICADO” que tenga la palabra “OK” para todos los registros.

SELECT JLEON.CUSTOMERS.NAME, JLEON.CUSTOMERS.LAST_NAME, JLEON.CUSTOMERS.AGE, JLEON.CUSTOMERS_VEHICLES_RELATION.MILEAGE_KM, JLEON.VEHICLES.BRAND, JLEON.VEHICLES.MODEL, JLEON.VEHICLES.YEAR, JLEON.VEHICLES.COLOR, 'OK' AS VERIFIED
FROM JLEON.CUSTOMERS
INNER JOIN JLEON.CUSTOMERS_VEHICLES_RELATION ON JLEON.CUSTOMERS.ID_CUSTOMER = JLEON.CUSTOMERS_VEHICLES_RELATION.ID_CUSTOMER
INNER JOIN JLEON.VEHICLES ON JLEON.CUSTOMERS_VEHICLES_RELATION.ID_VEHICLE = JLEON.VEHICLES.ID_VEHICLE
ORDER BY JLEON.CUSTOMERS.LAST_NAME, JLEON.CUSTOMERS.NAME;

-- Create View and Give Access to JLEON
CREATE VIEW T2_LOPEZ_JUAN_16 AS SELECT JLEON.CUSTOMERS.NAME, JLEON.CUSTOMERS.LAST_NAME, JLEON.CUSTOMERS.AGE, JLEON.CUSTOMERS_VEHICLES_RELATION.MILEAGE_KM, JLEON.VEHICLES.BRAND, JLEON.VEHICLES.MODEL, JLEON.VEHICLES.YEAR, JLEON.VEHICLES.COLOR, 'OK' AS VERIFIED
FROM JLEON.CUSTOMERS
INNER JOIN JLEON.CUSTOMERS_VEHICLES_RELATION ON JLEON.CUSTOMERS.ID_CUSTOMER = JLEON.CUSTOMERS_VEHICLES_RELATION.ID_CUSTOMER
INNER JOIN JLEON.VEHICLES ON JLEON.CUSTOMERS_VEHICLES_RELATION.ID_VEHICLE = JLEON.VEHICLES.ID_VEHICLE
ORDER BY JLEON.CUSTOMERS.LAST_NAME, JLEON.CUSTOMERS.NAME;

-- Grant Access to JLEON
GRANT SELECT ON IS324304.T2_LOPEZ_JUAN_16 TO JLEON;

-- SECTION 4

-- En ocasiones se deben obtener fuentes de datos desde diferentes sistemas o tecnologías.
-- Los datos se pueden encontrar en bases de datos, apis, archivos, entre otros. Para este
-- ejercicio se requieren 3 fuentes de datos.
-- o Tabla en BD jleon.videogames_sales: Contiene información relevante de la venta de
-- videojuegos incluyendo las ventas (en millones de dólares).
-- o Tabla “videogamesDates”: Información de fecha exacta de salida de videojuegos, se
-- obtiene como información desde la web.
-- o Tabla “TRM”: Información de TRM para Colombia, se obtiene desde datos abiertos
-- de Colombia.

-- 17)  Para la tabla “videogamesDates “: Descargar el dataset desde wikidata
-- (https://query.wikidata.org/) e ingresar los datos a la base de datos Oracle. Puede usar la
-- siguiente consulta de sparql:
-- SELECT ?game ?gameLabel ?releaseDate ?platformLabel ?periodLabel WHERE {
--  SERVICE wikibase:label { bd:serviceParam wikibase:language "[AUTO_LANGUAGE],en". }
--  ?game wdt:P31 wd:Q7889.
--  ?game wdt:P577 ?releaseDate .
--  ?game wdt:P400 ?platform .
--  ?game wdt:P2408 ?period .
-- }

--  Sub pasos:
-- Ingresar al link.
-- Correr el query.
-- Descargar el archivo en formato CSV.
-- Crear tabla 

-- - Indique paso a paso como cargó los datos (tenga en cuenta los tipos de datos, no todos
-- son cadenas de texto).
-- 18) Descargar el dataset desde datos abiertos de Colombia y cargarlo a la base de datos Oracle.
-- La ruta de descarga es: https://www.datos.gov.co/Econom-a-y-Finanzas/Tasa-de-CambioRepresentativa-del-Mercado-Historic/mcec-87by
-- - Indique paso a paso como cargó los datos (tenga en cuenta los tipos de datos, no todos
-- son cadenas de texto).

-- Profe, por alguna Razon del sistema fue posible cargar los CSV a la plataforma, oracle explorer
-- Ver archivo, sin embargo de acuerdo a los esquemas los queries correspondientess son los siguientes:

-- La tabla jleon.videogames_sales tiene el siguiente esquema:

--  DESCRIBE JLEON.VIDEOGAMES_SALES;
-- Name	Null?	Type
-- RANK_VGS	NOT NULL	NUMBER(10)
-- NAME	NOT NULL	VARCHAR2(150)
-- PLATFORM	NOT NULL	VARCHAR2(100)
-- YEAR		NUMBER(4)
-- GENRE		VARCHAR2(100)
-- PUBLISHER		VARCHAR2(100)
-- NA_SALES		NUMBER(6,2)
-- EU_SALES		NUMBER(6,2)
-- JP_SALES		NUMBER(6,2)
-- OTHER_SALES		NUMBER(6,2)
-- GLOBAL_SALES		NUMBER(6,2)

-- La talbla videogameDates tiene el siguiente esquema:

-- game,gameLabel,releaseDate,platformLabel,periodLabel
-- http://www.wikidata.org/entity/Q45028,Halo 4,2012-11-06T00:00:00Z,Xbox 360,future
-- http://www.wikidata.org/entity/Q45028,Halo 4,2012-11-06T00:00:00Z,Xbox One,future
-- http://www.wikidata.org/entity/Q137802,Halo 3,2007-09-25T00:00:00Z,Microsoft Windows,future
-- http://www.wikidata.org/entity/Q137802,Halo 3,2007-09-25T00:00:00Z,Xbox 360,future
-- http://www.wikidata.org/entity/Q137802,Halo 3,2007-09-25T00:00:00Z,Xbox One,future
-- http://www.wikidata.org/entity/Q137802,Halo 3,2007-09-26T00:00:00Z,Microsoft Windows,future
-- http://www.wikidata.org/entity/Q137802,Halo 3,2007-09-26T00:00:00Z,Xbox 360,future
-- http://www.wikidata.org/entity/Q137802,Halo 3,2007-09-26T00:00:00Z,Xbox One,future

-- La tabla TRM tiene el siguiente esquema:

-- VALOR,UNIDAD,VIGENCIADESDE,VIGENCIAHASTA
-- 4761.64,COP,22/12/2022,22/12/2022
-- 4781.28,COP,20/12/2022,20/12/2022
-- 4802.48,COP,17/12/2022,19/12/2022
-- 4836.24,COP,13/12/2022,13/12/2022
-- 4815.99,COP,10/12/2022,12/12/2022

-- Los queries serian los siguientes: 

-- 19) Actualice la columna de “plataforma” en la tabla “videogamesDates” para que sean
-- congruentes con la columna de “plataforma” en la tabla “videogames_sales”. Puede usar la
-- sentencia CASE, WHEN.

UPDATE JLEON.VIDEOGAMES_DATES SET JLEON.VIDEOGAMES_DATES.PLATFORM = JL.VIDEOGAMES_SALES.PLATFORM WHERE JLEON.VIDEOGAMES_DATES.PLATFORM = JL.VIDEOGAMES_SALES.PLATFORM;

-- 20) De la tabla “videogamesDates”, encuentre la cantidad de juegos que se estrenaron en cada
-- año y cada mes, entre los años 2000 y 2020. Muestre el resultado ordenado por año y mes.
-- Puede usar la función EXTRACT y TO_DATE para lograr los resultados esperados.

SELECT EXTRACT(YEAR FROM TO_DATE(JLEON.VIDEOGAMES_DATES.RELEASEDATE, 'YYYY-MM-DD')), 
EXTRACT(MONTH FROM TO_DATE(JLEON.VIDEOGAMES_DATES.RELEASEDATE, 'YYYY-MM-DD')), COUNT(*) FROM 
JLEON.VIDEOGAMES_DATES WHERE EXTRACT(YEAR FROM TO_DATE(JLEON.VIDEOGAMES_DATES.RELEASEDATE, 'YYYY-MM-DD')) 
BETWEEN 2000 AND 2020 GROUP BY EXTRACT(YEAR FROM TO_DATE(JLEON.VIDEOGAMES_DATES.RELEASEDATE, 'YYYY-MM-DD')), 
EXTRACT(MONTH FROM TO_DATE(JLEON.VIDEOGAMES_DATES.RELEASEDATE, 'YYYY-MM-DD')) 
ORDER BY EXTRACT(YEAR FROM TO_DATE(JLEON.VIDEOGAMES_DATES.RELEASEDATE, 'YYYY-MM-DD')), EXTRACT(MONTH FROM TO_DATE(JLEON.VIDEOGAMES_DATES.RELEASEDATE, 'YYYY-MM-DD'));

-- 21) Encuentre un top 10 de los años y meses en donde más juegos fueron liberados entre los
-- años 1990 y 2000. Solo tenga en cuenta aquellos años y meses donde se liberaron menos
-- de 5 juegos.

SELECT EXTRACT(YEAR FROM TO_DATE(JLEON.VIDEOGAMES_DATES.RELEASEDATE, 'YYYY-MM-DD')), 
EXTRACT(MONTH FROM TO_DATE(JLEON.VIDEOGAMES_DATES.RELEASEDATE, 'YYYY-MM-DD')), COUNT(*) FROM 
JLEON.VIDEOGAMES_DATES WHERE EXTRACT(YEAR FROM TO_DATE(JLEON.VIDEOGAMES_DATES.RELEASEDATE, 'YYYY-MM-DD')) 
BETWEEN 1990 AND 2000 GROUP BY EXTRACT(YEAR FROM TO_DATE(JLEON.VIDEOGAMES_DATES.RELEASEDATE, 'YYYY-MM-DD')), 
EXTRACT(MONTH FROM TO_DATE(JLEON.VIDEOGAMES_DATES.RELEASEDATE, 'YYYY-MM-DD')) 
HAVING COUNT(*) > 5 ORDER BY COUNT(*) DESC;

-- 22) Encuentre el valor en pesos colombianos (COP) de las ventas globales para cada juego en
-- cada plataforma. Use el valor de la tasa representativa de el día en que el juego fue lanzado.
-- Para los registros que no crucen de las tablas de videojuegos, deje como valor el precio en
-- dólares negativo (ejemplo: -2.25).

SELECT JLEON.VIDEOGAMES_SALES.NAME, ROUND(JLEON.VIDEOGAMES_SALES.GLOBAL_SALES * TRM.VALOR, 2) FROM 
JLEON.VIDEOGAMES_SALES, TRM ORDER BY JLEON.VIDEOGAMES_SALES.GLOBAL_SALES * TRM.VALOR DESC;





















